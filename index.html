<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>TOTEM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Tells iOS Safari: open in standalone web-app mode -->
  <meta name="mobile-web-app-capable" content="yes">
  <!-- Optional: define a default colour for the status bar -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="icon" type="image/png" href="totem.png">
  <link rel="apple-touch-icon" href="totem.png">

  <style>
/* Global settings: black background, sans-serif font */
body {
  margin: 0;
  font-family: sans-serif;
  background-color: #000;
}

/* Reader container: black background with an overlay for gradient effect */
#readerContainer {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  min-height: 800px; /* increased min-height */
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  box-sizing: border-box;
  padding: 10px;
  overflow-y: auto;
  position: relative;
  background-color: #000; /* ensure background remains black */
}

/* Overlay pseudo-element with vertical gradient and blend mode */
#readerContainer::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* Vertical gradient: starts with dark red and transitions to lighter red */
  background: linear-gradient(to bottom, rgb(250, 0, 0), rgb(200, 0, 0));
  mix-blend-mode: darken; /* Blend mode applied to the overlay */
  pointer-events: none;  /* Allow clicks/selection on text underneath */
  z-index: 3;
}

/* Text lines: placed above the overlay */
.line {
  margin: 0;
  text-align: center;
  word-wrap: break-word;
  font-size: 1.4em;
  color: #ff9797; /* Base dark red */
  position: relative;
  z-index: 2; /* Ensure text is above the overlay */
}

/* Page number + go button container */
#pageJumpContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px 0;
  position: relative;
  z-index: 2;
}

#pageJumpContainer input {
  width: 70px;
  font-size: 16px;
  margin-right: 5px;
  color: #fff;
  background: #333;
  border: 1px solid #555;
  padding: 4px;
}

#pageJumpContainer button {
  padding: 8px 14px;
  font-size: 16px;
  cursor: pointer;
  background: #333;
  color: #fff;
  border: 1px solid #555;
}

/* File list container styling */
#fileListContainer {
  text-align: center;
  margin-bottom: 10px;
  position: relative;
  z-index: 2;
}

#fileListContainer button {
  margin: 3px;
  padding: 5px 10px;
  background: #333;
  color: #fff;
  border: 1px solid #555;
  cursor: pointer;
}

/* Page info styling */
#pageInfo {
  text-align: center;
  margin-bottom: 10px;
  position: relative;
  color: #fff;
  z-index: 20;
}
  </style>
</head>
<body>

  <!-- The text display area at the top -->
  <div id="readerContainer"></div>

  <!-- Page number + "Go" button on its own line -->
  <div id="pageJumpContainer">
    <input type="number" id="pageNumberInput" min="1" />
    <button id="goPageBtn">Go</button>
  </div>

  <!-- Page info (e.g. "Page X of Y") -->
  <div id="pageInfo"></div>

  <!-- List of stored files (from the root directory) -->
  <div id="fileListContainer"></div>

  <script>
    const WORDS_PER_PAGE = 21;

    const FILE_NAMES = [
      "Our-Oriental-Heritage.txt",
      "RISE.txt"
    ];

    /********************************************************
     * Global Variables
     ********************************************************/
    const readerContainer = document.getElementById('readerContainer');
    const goPageBtn = document.getElementById('goPageBtn');
    const pageNumberInput = document.getElementById('pageNumberInput');
    const pageInfo = document.getElementById('pageInfo');
    const fileListContainer = document.getElementById('fileListContainer');

    // IndexedDB config
    const DB_NAME = 'myEreaderDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'textFiles';

    let db;                // will hold our IndexedDB instance
    let allWords = [];     // Current file's tokens
    let currentPage = 0;

    let currentFileName = '';  // Which file is currently loaded
    let storedFiles = [];      // In-memory: [{ name, content, lastPage }, ...]

    /********************************************************
     * On Page Load (DOMContentLoaded)
     ********************************************************/
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('[DOMContentLoaded] Initialising IndexedDB...');
      try {
        await initIndexedDB();
        console.log('[DOMContentLoaded] Attempting to fetch files from root...');
        await fetchAndStoreFiles();            // 1) fetch & store
        await loadStoredFilesFromIndexedDB();  // 2) load list
        updateFileListUI();                    // 3) build UI

        // Auto-load the last opened file (if any)
        const lastFile = localStorage.getItem('lastOpenedFile');
        if (lastFile) {
          console.log(`[DOMContentLoaded] Auto-loading lastOpenedFile: ${lastFile}`);
          loadFileByName(lastFile);
        }
      } catch (err) {
        console.error('Error during initialization:', err);
      }
    });

    /********************************************************
     * IndexedDB Initialisation
     ********************************************************/
    function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = (event) => {
          console.error('[initIndexedDB] Error opening DB:', event.target.error);
          reject(event.target.error);
        };

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'name' });
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          resolve();
        };
      });
    }

    /********************************************************
     * 1) Fetch & Store .txt files in IndexedDB
     ********************************************************/
    async function fetchAndStoreFiles() {
      for (const fileName of FILE_NAMES) {
        try {
          const response = await fetch(fileName, { cache: 'reload' });
          if (!response.ok) {
            throw new Error(`Network response was not ok for ${fileName}`);
          }
          const textContent = await response.text();
          console.log(`[fetchAndStoreFiles] Fetched "${fileName}" (length=${textContent.length}).`);

          // Preserve lastPage if record exists
          const oldRecord = await getFileFromDB(fileName);
          const oldLastPage = oldRecord ? oldRecord.lastPage : 0;

          await saveFileToIndexedDB(fileName, textContent, oldLastPage);

        } catch (err) {
          console.warn(`[fetchAndStoreFiles] Could NOT fetch "${fileName}" => ${err.message}`);
          // If offline or file missing, just skip
        }
      }
    }

    function getFileFromDB(fileName) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(fileName);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror   = () => reject(request.error);
      });
    }

    /********************************************************
     * 2) Save file content into IndexedDB
     ********************************************************/
    function saveFileToIndexedDB(name, content, lastPage) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.put({ name, content, lastPage });
        tx.oncomplete = () => resolve();
        tx.onerror    = () => reject(tx.error);
      });
    }

    /********************************************************
     * 3) Load all stored files from IndexedDB
     ********************************************************/
    function loadStoredFilesFromIndexedDB() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          storedFiles = request.result || [];
          console.log(`[loadStoredFilesFromIndexedDB] Found ${storedFiles.length} stored files.`);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }

    /********************************************************
     * Build UI: file list
     ********************************************************/
    function updateFileListUI() {
      fileListContainer.innerHTML = '';
      if (storedFiles.length === 0) {
        fileListContainer.textContent = 'No stored files yet.';
        return;
      }

      storedFiles.forEach(fileObj => {
        const btn = document.createElement('button');
        btn.textContent = fileObj.name;
        btn.addEventListener('click', () => {
          loadFileByName(fileObj.name);
        });
        fileListContainer.appendChild(btn);
      });
    }

    /********************************************************
     * Load a file by name, tokenise, and display
     ********************************************************/
    async function loadFileByName(name) {
      const fileObj = storedFiles.find(item => item.name === name);
      if (!fileObj) {
        console.warn(`[loadFileByName] Could not find file "${name}".`);
        return;
      }
      currentFileName = name;
      localStorage.setItem('lastOpenedFile', currentFileName);

      console.log(`[loadFileByName] Loading file "${name}" with lastPage=${fileObj.lastPage}`);

      tokenizeAndLoad(fileObj.content);

      currentPage = fileObj.lastPage || 0;
      displayPage();
      updatePageInfo();
    }

    /********************************************************
     * Tokenise & Display
     ********************************************************/
    function tokenizeAndLoad(text) {
      // Split text into paragraphs by blank lines
      const paragraphs = text.split(/\r?\n\r?\n+/);

      let combinedTokens = [];

      paragraphs.forEach(par => {
        const trimmedPar = par.trim();
        if (trimmedPar) {
          // Regex that keeps hyphenated words together
          const pTokens = trimmedPar.match(/[^\s–—]+(?:-[^\s–—]+)*|[–—]+|-+/g);
          if (pTokens) {
            combinedTokens.push(...pTokens);
          }
        }
        // Add empty string to represent blank line
        combinedTokens.push("");
      });

      // Remove trailing blank if any
      if (combinedTokens.length > 0 && combinedTokens[combinedTokens.length - 1] === "") {
        combinedTokens.pop();
      }

      allWords = combinedTokens;
      console.log(`[tokenizeAndLoad] Found ${allWords.length} tokens (incl. blank lines).`);
    }

    function displayPage() {
      readerContainer.innerHTML = '';

      const startIndex = currentPage * WORDS_PER_PAGE;
      const endIndex = startIndex + WORDS_PER_PAGE;
      const pageWords = allWords.slice(startIndex, endIndex);

      pageWords.forEach(word => {
        const p = document.createElement('p');
        p.className = 'line';

        if (word === "") {
          p.innerHTML = "&nbsp;"; // blank line
        } else {
          p.innerHTML = makeFirstCharacterBold(word);
        }
        readerContainer.appendChild(p);
      });

      updatePageInfo();
    }

    function makeFirstCharacterBold(word) {
      return word; // currently not bolding first character
    }

    /********************************************************
     * Touch & Click for Page Navigation
     *
     * Tap anywhere on the text box moves forward one page (via click).
     * A horizontal swipe (left or right) moves back one page (via touchend).
     * We suppress only the *ghost click* that follows a swipe.
     ********************************************************/

    let touchStartX = 0, touchStartY = 0;

    // NEW: timestamp-based ghost-click suppression
    let lastSwipeAt = 0;
    const SWIPE_GHOST_CLICK_MS = 350; // ignore clicks that happen right after a swipe

    // Record the starting touch coordinates.
    readerContainer.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    // On touchend, check for a horizontal swipe.
    readerContainer.addEventListener('touchend', (e) => {
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const threshold = 30; // Minimum horizontal movement (px) to be considered a swipe

      // Trigger only if horizontal movement is significant and greater than vertical movement.
      if (Math.abs(deltaX) > threshold && Math.abs(deltaX) > Math.abs(deltaY)) {
        changePage(-1);                // swipe => go back one page
        lastSwipeAt = Date.now();      // mark when we swiped
        e.preventDefault();            // try to stop the ghost click
      }
    });

    // A simple tap (click) moves forward, unless it's the ghost click after a swipe.
    readerContainer.addEventListener('click', (e) => {
      if (Date.now() - lastSwipeAt < SWIPE_GHOST_CLICK_MS) return; // ignore ghost click
      changePage(1); // real tap => go forward one page
    });

    /********************************************************
     * "Go" button => jump to page
     ********************************************************/
    goPageBtn.addEventListener('click', () => {
      const pageNumber = parseInt(pageNumberInput.value, 10);
      if (!pageNumber || pageNumber < 1) return;

      const totalPages = Math.ceil(allWords.length / WORDS_PER_PAGE);
      const newPage = Math.min(totalPages, pageNumber) - 1; // clamp

      console.log(`[goPageBtn] Jumping from page ${currentPage} to page ${newPage}.`);
      currentPage = newPage;
      displayPage();
      saveCurrentPage();
    });

    /********************************************************
     * Pagination helpers
     ********************************************************/
    function changePage(delta) {
      const totalPages = Math.ceil(allWords.length / WORDS_PER_PAGE);
      const oldPage = currentPage;
      currentPage += delta;

      if (currentPage < 0) currentPage = 0;
      if (currentPage >= totalPages) currentPage = totalPages - 1;

      console.log(`[changePage] Changing page from ${oldPage} to ${currentPage} (delta=${delta}).`);
      displayPage();
      saveCurrentPage(); // Save as soon as we change page
    }

    /********************************************************
     * Save & Restore "lastPage" for each file (in IndexedDB)
     ********************************************************/
    function saveCurrentPage() {
      if (!currentFileName) {
        console.warn('[saveCurrentPage] No currentFileName set; cannot save page.');
        return;
      }
      const idx = storedFiles.findIndex(item => item.name === currentFileName);
      if (idx < 0) {
        console.warn(`[saveCurrentPage] Could not find file "${currentFileName}" in storedFiles array.`);
        return;
      }
      storedFiles[idx].lastPage = currentPage;

      saveFileToIndexedDB(
        currentFileName,
        storedFiles[idx].content,
        currentPage
      )
      .then(() => {
        console.log(`[saveCurrentPage] Saved page=${currentPage} for file "${currentFileName}" in DB.`);
      })
      .catch(err => {
        console.error('[saveCurrentPage] Error saving page:', err);
      });
    }

    function updatePageInfo() {
      const totalPages = Math.max(1, Math.ceil(allWords.length / WORDS_PER_PAGE));
      pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
    }
  </script>
</body>
</html>
